<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality · Gtk.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="Gtk.jl logo"/></a><h1>Gtk.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/gettingStarted/">Getting Started</a></li><li><a class="toctext" href="../../manual/properties/">Properties</a></li><li><a class="toctext" href="../../manual/layout/">Layout</a></li><li><a class="toctext" href="../../manual/signals/">Signals and Callbacks</a></li><li><a class="toctext" href="../../manual/builder/">Builder and Glade</a></li><li><a class="toctext" href="../../manual/textwidgets/">Text Widgets</a></li><li><a class="toctext" href="../../manual/combobox/">Combobox</a></li><li><a class="toctext" href="../../manual/listtreeview/">List and Tree Widgets</a></li><li><a class="toctext" href="../../manual/filedialogs/">Dialogs</a></li><li><a class="toctext" href="../../manual/keyevents/">Key Events</a></li><li><a class="toctext" href="../../manual/canvas/">Drawing on Canvas</a></li><li><a class="toctext" href="../../manual/customWidgets/">Custom/Composed Widgets</a></li><li><a class="toctext" href="../../manual/async/">Asynchronous UI</a></li><li><a class="toctext" href="../../manual/nonreplusage/">Non REPL Usage</a></li><li><a class="toctext" href="../../manual/packages/">High-Level Packages</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphics/Gtk.jl/blob/master/docs/src/doc/developer.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Gtk-Developer-Oriented-Documentation:-Extending-Gtk.jl’s-functionality-1" href="#Gtk-Developer-Oriented-Documentation:-Extending-Gtk.jl’s-functionality-1">Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality</a></h1><hr/><h2><a class="nav-anchor" id="Implementing-New-Gtk-Types-1" href="#Implementing-New-Gtk-Types-1">Implementing New Gtk Types</a></h2><p>You can subclass an existing Gtk type in Julia using the following code pattern:</p><pre><code class="language-none">type MyWidget &lt;: Gtk.GtkButton
    handle::Ptr{Gtk.GObject}
    other_fields
    function MyWidget(label)
        btn = @GtkButton(label)
        Gtk.gobject_move_ref(new(btn), btn)
    end
end</code></pre><p>This creates a <code>MyWidget</code> type which inherits its behavior from <code>GtkButton</code>. The <code>gobject_move_ref</code> call transfers ownership of the <code>GObject</code> handle from <code>GtkButton</code> to <code>MyWidget</code> in a gc-safe manner. Afterwards, the <code>btn</code> object is invalid and converting from the <code>Ptr{GtkObject}</code> to <code>GtkObject</code> will return the <code>MyWidget</code> object.</p><p>New native Gtk types can be most easily added by invoking the <code>Gtk.@GTypes</code> macro:</p><pre><code class="language-none"> Gtk.@GTypes GTypeName library_variable sym_name
 Gtk.@GTypes GTypeName library_variable gtyp_getter_expr</code></pre><p>and then defining the appropriate outer constructors. Note that the <code>@GTypes</code> macro expects a variable <code>suffix</code> to be defined in the current module, which will be appended to the name of the type to create a unique type instance.</p><p>Please pay attention to existing constructors that already exist to avoid user confusion: for example, the first argument to a <code>GtkContainer</code> may optionally be its first child widget. And keyword arguments are reserved for setting properties after construction.</p><hr/><h2><a class="nav-anchor" id="Utility-functions-1" href="#Utility-functions-1">Utility functions</a></h2><h3><a class="nav-anchor" id="GLib.bytestring(ptr,-own::Bool)-1" href="#GLib.bytestring(ptr,-own::Bool)-1"><code>GLib.bytestring(ptr, own::Bool)</code></a></h3><p>This no-copy variant of <code>bytestring</code> allows you to specify whether Julia &quot;owns&quot; the memory pointed to by <code>ptr</code> (similar to <code>Base.pointer_to_array</code>). This is useful for <code>GList</code> iteration when wishing to return strings created by a Gtk object, and other APIs that return a newly allocated string.</p><h3><a class="nav-anchor" id="GLib.gc_ref(x::ANY)-/-GLib.gc_unref(x::ANY)-/-GLib.gobject_ref(x::GObject)-1" href="#GLib.gc_ref(x::ANY)-/-GLib.gc_unref(x::ANY)-/-GLib.gobject_ref(x::GObject)-1"><code>GLib.gc_ref(x::ANY)</code> / <code>GLib.gc_unref(x::ANY)</code> / <code>GLib.gobject_ref(x::GObject)</code></a></h3><p>As the names suggests, these functions increase / decrease the reference count of a Julia object <code>x</code>, to prevent garbage-collection of this object while it is in use by <code>Glib</code>. Note that <code>GLib.gc_unref(w::GObject)</code> should typically not be called, since it will immediately destroy the Julia reference <code>w</code>, and will be called automatically by the Julia garbage-collector once their are no remaining references to this object (in GLib or Julia). The function <code>gc_ref</code> returns a pointer to the gc-protected memory (as a <code>*jl_value_t</code> / <code>Ptr{Nothing}</code>) for use in ccall, whereas <code>gobject_ref</code> returns <code>x</code> for use in method chaining.</p><h3><a class="nav-anchor" id="mutable{T}(::Type{T})-1" href="#mutable{T}(::Type{T})-1"><code>mutable{T}(::Type{T})</code></a></h3><p>Creates a new box to contain an reference to an instance of <code>T</code></p><h3><a class="nav-anchor" id="mutable(x,-i1)-1" href="#mutable(x,-i1)-1"><code>mutable(x, i=1)</code></a></h3><p>Creates a new box (with optional offset index <code>i==1</code>) initialized to contain <code>x</code></p><h3><a class="nav-anchor" id="mutable(x::Union{Ptr,Array,Mutable},-i1)-1" href="#mutable(x::Union{Ptr,Array,Mutable},-i1)-1"><code>mutable(x::Union{Ptr,Array,Mutable}, i=1)</code></a></h3><p>Returns the reference to the box, <code>x</code>, optionally offset by index <code>i</code></p><hr/><h2><a class="nav-anchor" id="GLib.MutableTypes-1" href="#GLib.MutableTypes-1">GLib.MutableTypes</a></h2><p>The <code>GLib.MutableTypes</code> module provides methods for seamlessly working with various forms of boxed <code>immutable</code> (or <code>mutable</code>) objects. An immutable object could be boxed in a <code>Ptr</code> and <code>Array</code>, or an <code>MutableTypes.MutableX</code> singleton wrapper. Therefore, the <code>mutable</code> class helps to seamlessly merge all three into a single interface.</p><p>Given a <code>mutable</code> object, the user can extract the data in one of three ways:</p><ul><li>Using <code>[]</code> (<code>getindex</code>) notation is convenient short-hand, but is not defined for pointers</li><li>If the <code>mutable</code> object reference might be a pointer, instead choose either of the <code>deref</code> or <code>unsafe_load</code> function names. Their behavior is identical for the types in the <code>MutableTypes</code> module, but they might have had different fallback methods added externally.</li></ul><p>Updating the value is a <code>mutable</code> object reference can also be done in one of three ways:</p><ul><li>By passing the mutable object to <code>ccall</code>, with type signature <code>Ptr{T}</code></li><li>Using <code>[] =</code> (<code>setindex!</code>) is convenient short-hand notation, but is not defined for pointers</li><li>If the <code>mutable</code> object reference might be a pointer, instead call <code>unsafe_store!</code></li></ul><hr/><h2><a class="nav-anchor" id="GLists-1" href="#GLists-1">GLists</a></h2><h3><a class="nav-anchor" id="Basic-Usage-1" href="#Basic-Usage-1">Basic Usage</a></h3><p>Gtk functions that return a <code>GLib.GList</code> can be used in Julia&#39;s iteration syntax in the following way:</p><pre><code class="language-none">for obj in ccall((:gtk_function_that_returns_a_GList,libgtk),
        Ptr{_GSList{T}}, (ArgTypes...,), args...)
    # do something with obj
end</code></pre><h3><a class="nav-anchor" id="Return-Type-1" href="#Return-Type-1">Return Type</a></h3><p>The returned instance <code>obj</code> will be of type <code>eltype(_GSList{T})</code>, where for <code>T</code> you have picked the expected element return type. See <a href="#glist-eltype-representations">below</a> for more details on the storage characteristics for various choices of <code>T</code></p><h3><a class="nav-anchor" id="GC-Safety-1" href="#GC-Safety-1">GC Safety</a></h3><p>Depending on where you acquired your <code>GLib.GList</code>, you will need to select the appropriate method to provide seamless garbage-collection integration.</p><ol><li>A naked <code>ptr=Ptr{_GSList{T}}</code> is never garbage-collected by Julia. This is useful when iterating over a <code>GLib.GSList</code> (or <code>GLib.GList</code>) from <code>GLib</code> which still owned by the object <code>[transfer-none]</code></li><li>Wrapping the pointer in a call to <code>GLib.GList(ptr)</code> will free the list when the returned <code>GList</code> object reference is garbage-collected <code>[transfer-container]</code></li><li>Wrapping the pointer instead in a call to <code>glist_iter(ptr)</code> will wrap the list in GC-safe iterator. By contrast to calling <code>GLib.GList(ptr)</code>, this method is necessary if the user is unlikely to be able to maintain the a reference to the returned object for the life of the iterator. Instances where this is true include iterators (hence the name), since this function is often used to create iterators: <code>start(x) = glist_iter(get_ptr_to_glist(x))</code>. <code>[transfer-container]</code></li><li>To both 2 and 3, you can supply an additional boolean parameter <code>transfer-full</code>, to have Julia also dereference and free the individual elements <code>[transfer-full]</code></li><li>WARNING: ensure the choice of <code>_GSList</code> vs <code>_GList</code> matches the Gtk API exactly. Using the wrong one will corrupt the GSlice allocator.</li></ol><h3><a class="nav-anchor" id="Julia-allocated-GLists-1" href="#Julia-allocated-GLists-1">Julia-allocated GLists</a></h3><p>You can create and manipulate a new doubly-linked <code>GList</code> object from Julia by calling the <code>GList(T)</code> constructor, where <code>T</code> is the <code>eltype</code> of the pointers that you want this list to be able to hold.</p><pre><code class="language-none">list = GList(Int) # similar to Array(Int,1)
list[1]</code></pre><p>By default, these are allocated as <code>[transfer-full]</code>, meaning it will deallocate all of its elements when the list is destroyed. However, like all <code>GList</code> constructors, it takes an <code>transfer_full</code> argument, which can be set to false to have Julia reference it as <code>[tranfer-container]</code>.</p><p>To transfer ownership of the GList, you can extract the <code>GList.handle</code> from list, and the set <code>GList.handle = C_NULL</code> to reset it.</p><p>A <code>GList</code> conforms to the <code>AbstractVector</code> interface, and can be used in most contexts that an <code>Array</code> could be used.</p><h3><a class="nav-anchor" id="GList-eltype-Representations-1" href="#GList-eltype-Representations-1">GList <code>eltype</code> Representations</a></h3><ul><li><code>GList{T&lt;:GObject} stores references to</code>GObject`</li><li><code>GList{T&lt;:Any}</code> stores Julia object references</li><li><code>GList{T&lt;:Ptr}</code> stores pointers, without alteration</li><li><code>GList{T&lt;:Number}</code> stores numbers inside the pointer (generally only works with Integer, and size must be &lt;= sizeof(int) == 32 bits)</li><li><code>GList{T&lt;:Ptr{Number}}</code> stores individually <code>g_malloc</code>-created boxed numerical type objects</li></ul><p>You can add your own conversions by defining the appropriate <code>eltype  -&gt; return type</code>, <code>GLib.ref_to -&gt; makes a pointer from an object</code>, <code>GLib.deref_to -&gt; makes an object from a pointer</code>, and <code>empty! -&gt; frees the contents of a list object of this type</code> methods (see the bottom of <code>GLib/glist.jl</code> for examples.</p><hr/><h2><a class="nav-anchor" id="Adding-new-GValueJulia-auto-conversions-1" href="#Adding-new-GValueJulia-auto-conversions-1">Adding new <code>GValue</code>⇄<code>Julia</code> auto-conversions</a></h2><p>New GValue-to-Julia conversions can be implemented via the <code>Gtk.make_gvalue(pass_x,as_ctype,to_gtype,with_id,allow_reverse::Bool=true)</code> function. This adds all of the appropriate methods to getindex, setindex!, and gvalue to handle converting this value to and from a GValue.</p><ul><li><code>pass_x</code> is the Julia type</li><li><code>as_ctype</code> is the type for ccall</li><li><code>to_gtype</code> is the name of the <code>g_value_get_*</code> <code>g_value_set_*</code> method to use</li><li><code>with_id</code> specifies the type identifier. It must resolve to an Int, but can either be a variable, and Integer, or a tuple of the type name and library where the <code>_get_type</code> function can be called</li><li><code>allow_reverse</code> specifies whether this entry should be used for auto-unpacking</li></ul><p>Note that this calls Core.eval on its arguments in the current module, so if you want to use a symbol from Gtk (such as <code>Gtk.libgtk</code>, make sure you give the fully qualified name). You will also need to ensure the appropriate convert methods exist to translate from <code>pass_x</code> to <code>as_ctype</code> and back. <code>make_gvalue</code> does a few automatic transformations:</p><ul><li>if the <code>to_gtype</code> is <code>:string</code> or <code>:static_string</code>, make_gvalue will insert calls to bytestring</li><li>if the <code>to_gtype</code> is <code>:pointer</code> or <code>:boxed</code>, make_gvalue will insert code (a call to <code>Gtk.mutable</code>) that converts from <code>Type</code> -&gt; <code>Ptr{Type}</code> in the <code>setindex!</code> method. Providing a conversion from <code>Ptr{Type}</code> -&gt; <code>Type</code> must be handled by the user.</li></ul><p>For example:</p><pre><code class="language-none">Gtk.make_gvalue(Gtk.GdkRectangle, Ptr{Gtk.GdkRectangle}, :boxed, (:gdk_rectangle,:(Gtk.libgdk)))
Base.convert(::Type{Gtk.GdkRectangle}, rect::Ptr{Gtk.GdkRectangle}) = unsafe_load(rect)</code></pre><footer><hr/></footer></article></body></html>
